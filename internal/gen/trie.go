// Package trie handles the generation of compressed tries for character properties
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"os"
	"unicode"

	"github.com/clipperhouse/displaywidth/internal/gen/triegen"
)

// GenerateTrie creates a compressed trie from Unicode data using triegen
func GenerateTrie(data *UnicodeData) (*triegen.Trie, error) {
	trie := triegen.NewTrie("stringWidth")

	// Insert all characters with non-default properties
	inserted := 0
	for r := rune(0); r <= 0x10FFFF; r++ {
		// Skip surrogate characters (U+D800-U+DFFF) and other invalid characters
		if r >= 0xD800 && r <= 0xDFFF {
			continue
		}

		// Skip characters that would create invalid UTF-8
		if r == unicode.ReplacementChar {
			continue
		}

		props := BuildPropertyBitmap(r, data)

		// Only insert characters with non-default properties
		if props != 0 {
			trie.Insert(r, uint64(props))
			inserted++
		}
	}

	fmt.Printf("Inserted %d characters with non-default properties\n", inserted)
	return trie, nil
}

// WriteTrieGo generates the Go code for the trie using triegen
func WriteTrieGo(trie *triegen.Trie, outputPath string) error {
	buf := &bytes.Buffer{}

	// Write package header
	fmt.Fprintf(buf, "// Code generated by internal/gen/main.go. DO NOT EDIT.\n\n")
	fmt.Fprintf(buf, "package displaywidth\n\n")
	fmt.Fprintf(buf, "import \"github.com/clipperhouse/displaywidth/internal/stringish\"\n\n")

	// Write property definitions
	writeProperties(buf)

	// Generate the trie using triegen (it will use uint8/uint16/etc directly)
	size, err := trie.Gen(buf)
	if err != nil {
		return fmt.Errorf("failed to generate trie: %v", err)
	}

	b := buf.Bytes()
	typename := "stringWidthTrie"

	typeDefSig := `type ` + typename + ` struct`
	noTypeDef := `// ` + typeDefSig
	b = bytes.ReplaceAll(b, []byte(typeDefSig), []byte(noTypeDef))

	lookupSig := `(t *` + typename + `) lookup(s []byte)`
	genericLookupSig := `lookup[T stringish.Interface](s T)`
	b = bytes.ReplaceAll(b, []byte(lookupSig), []byte(genericLookupSig))

	lookupValueSig := `(t *` + typename + `) lookupValue`
	genericLookupValueSig := `lookupValue`
	b = bytes.ReplaceAll(b, []byte(lookupValueSig), []byte(genericLookupValueSig))

	lookupCallSig := `t.lookupValue(`
	genericLookupCallSig := `lookupValue(`
	b = bytes.ReplaceAll(b, []byte(lookupCallSig), []byte(genericLookupCallSig))

	// Replace uint8 return type in lookup with property and add necessary casts
	b = bytes.ReplaceAll(b, []byte(") (v uint8, sz int)"), []byte(") (v property, sz int)"))
	b = bytes.ReplaceAll(b, []byte(") uint8 {"), []byte(") property {"))
	b = bytes.ReplaceAll(b, []byte("func lookupValue(n uint32, b byte) uint8"), []byte("func lookupValue(n uint32, b byte) property"))
	// Cast return values from Values array (uint8) to property
	b = bytes.ReplaceAll(b, []byte("return stringWidthValues["), []byte("return property(stringWidthValues["))
	b = bytes.ReplaceAll(b, []byte("], 1"), []byte("]), 1"))
	b = bytes.ReplaceAll(b, []byte("return uint8(stringWidthValues["), []byte("return property(stringWidthValues["))

	formatted, err := format.Source(b)
	if err != nil {
		return err
	}

	dst, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer dst.Close()

	_, err = dst.Write(formatted)
	if err != nil {
		return err
	}

	fmt.Printf("Generated trie with size %d bytes\n", size)
	return nil
}

// writeProperties writes the character properties definitions to the buffer.
// It uses PropertyDefinitions from unicode.go as the single source of truth.
func writeProperties(w io.Writer) {
	fmt.Fprintf(w, "// property represents the properties of a character as bit flags\n")
	fmt.Fprintf(w, "// The underlying type is uint8 since we only use %d bits for flags.\n", len(PropertyDefinitions))
	fmt.Fprintf(w, "type property uint8\n\n")
	fmt.Fprintf(w, "const (\n")

	for i, prop := range PropertyDefinitions {
		constName := "_" + prop.Name

		if i == 0 {
			fmt.Fprintf(w, "\t%s property = 1 << iota // %s\n", constName, prop.Comment)
		} else {
			fmt.Fprintf(w, "\t%s // %s\n", constName, prop.Comment)
		}
	}

	fmt.Fprintf(w, ")\n\n")
}
