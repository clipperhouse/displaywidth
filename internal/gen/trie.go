// Package trie handles the generation of compressed tries for character properties
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"os"
	"unicode"

	"github.com/clipperhouse/stringwidth/internal/gen/triegen"
)

// GenerateTrie creates a compressed trie from Unicode data using triegen
func GenerateTrie(data *UnicodeData) (*triegen.Trie, error) {
	trie := triegen.NewTrie("stringWidth")

	// Insert all characters with non-default properties
	inserted := 0
	for r := rune(0); r <= 0x10FFFF; r++ {
		// Skip surrogate characters (U+D800-U+DFFF) and other invalid characters
		if r >= 0xD800 && r <= 0xDFFF {
			continue
		}

		// Skip characters that would create invalid UTF-8
		if r == unicode.ReplacementChar {
			continue
		}

		props := BuildPropertyBitmap(r, data)

		// Only insert characters with non-default properties
		if props != 0 {
			trie.Insert(r, uint64(props))
			inserted++
		}
	}

	fmt.Printf("Inserted %d characters with non-default properties\n", inserted)
	return trie, nil
}

// WriteTrieGo generates the Go code for the trie using triegen
func WriteTrieGo(trie *triegen.Trie, outputPath string) error {
	buf := &bytes.Buffer{}

	// Write package header
	fmt.Fprintf(buf, "// Code generated by internal/gen/main.go. DO NOT EDIT.\n\n")
	fmt.Fprintf(buf, "package stringwidth\n\n")

	// Write character properties definitions
	writeCharProperties(buf)

	// Generate the trie using triegen
	size, err := trie.Gen(buf)
	if err != nil {
		return fmt.Errorf("failed to generate trie: %v", err)
	}

	b := buf.Bytes()
	formatted, err := format.Source(b)
	if err != nil {
		return err
	}

	dst, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer dst.Close()

	_, err = dst.Write(formatted)
	if err != nil {
		return err
	}

	fmt.Printf("Generated trie with size %d bytes\n", size)
	return nil
}

// writeCharProperties writes the character properties definitions
func writeCharProperties(w io.Writer) {
	fmt.Fprintf(w, "// property represents the properties of a character as bit flags\n")
	fmt.Fprintf(w, "type property uint16\n\n")
	fmt.Fprintf(w, "const (\n")
	fmt.Fprintf(w, "\t// East Asian Width properties\n")
	fmt.Fprintf(w, "\tEAW_Fullwidth property = 1 << iota // F\n")
	fmt.Fprintf(w, "\tEAW_Wide                            // W\n")
	fmt.Fprintf(w, "\tEAW_Halfwidth                       // H\n")
	fmt.Fprintf(w, "\tEAW_Narrow                          // Na\n")
	fmt.Fprintf(w, "\tEAW_Neutral                         // N\n")
	fmt.Fprintf(w, "\tEAW_Ambiguous                       // A\n\n")
	fmt.Fprintf(w, "\t// General categories\n")
	fmt.Fprintf(w, "\tIsCombiningMark                     // Mn, Mc, Me\n")
	fmt.Fprintf(w, "\tIsControlChar                       // C0, C1, DEL\n")
	fmt.Fprintf(w, "\tIsZeroWidth                         // ZWSP, ZWJ, ZWNJ, etc.\n")
	fmt.Fprintf(w, "\tIsEmoji                             // Emoji base characters\n")
	fmt.Fprintf(w, "\tIsEmojiModifier                     // Emoji modifiers\n")
	fmt.Fprintf(w, "\tIsEmojiVariationSelector            // Emoji variation selectors\n")
	fmt.Fprintf(w, ")\n\n")
}
