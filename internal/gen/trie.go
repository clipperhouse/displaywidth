// Package trie handles the generation of compressed tries for character properties
package main

import (
	"fmt"
	"os"
	"path/filepath"
	"unicode"

	"github.com/clipperhouse/stringwidth/internal/gen/triegen"
)

// GenerateTrie creates a compressed trie from Unicode data using triegen
func GenerateTrie(data *UnicodeData) (*triegen.Trie, error) {
	trie := triegen.NewTrie("stringWidth")

	// Insert all characters with non-default properties
	inserted := 0
	for r := rune(0); r <= 0x10FFFF; r++ {
		// Skip surrogate characters (U+D800-U+DFFF) and other invalid characters
		if r >= 0xD800 && r <= 0xDFFF {
			continue
		}

		// Skip characters that would create invalid UTF-8
		if r == unicode.ReplacementChar {
			continue
		}

		props := BuildPropertyBitmap(r, data)

		// Only insert characters with non-default properties
		if props != 0 {
			trie.Insert(r, uint64(props))
			inserted++
		}
	}

	fmt.Printf("Inserted %d characters with non-default properties\n", inserted)
	return trie, nil
}

// WriteTrieGo generates the Go code for the trie using triegen
func WriteTrieGo(trie *triegen.Trie, outputPath string) error {
	// Create output directory
	outputDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}

	// Generate the trie code
	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %v", err)
	}
	defer file.Close()

	// Write package header
	fmt.Fprintf(file, "// Code generated by internal/gen/main.go. DO NOT EDIT.\n\n")
	fmt.Fprintf(file, "package stringwidth\n\n")
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"unicode\"\n")
	fmt.Fprintf(file, ")\n\n")

	// Write character properties definitions
	writeCharProperties(file)

	// Generate the trie using triegen
	size, err := trie.Gen(file)
	if err != nil {
		return fmt.Errorf("failed to generate trie: %v", err)
	}

	// Write the lookup function that works with stringish
	writeLookupFunction(file)

	fmt.Printf("Generated trie with size %d bytes\n", size)
	return nil
}

// writeCharProperties writes the character properties definitions
func writeCharProperties(w *os.File) {
	fmt.Fprintf(w, "// property represents the properties of a character as bit flags\n")
	fmt.Fprintf(w, "type property uint16\n\n")
	fmt.Fprintf(w, "const (\n")
	fmt.Fprintf(w, "\t// East Asian Width properties\n")
	fmt.Fprintf(w, "\tEAW_Fullwidth property = 1 << iota // F\n")
	fmt.Fprintf(w, "\tEAW_Wide                            // W\n")
	fmt.Fprintf(w, "\tEAW_Halfwidth                       // H\n")
	fmt.Fprintf(w, "\tEAW_Narrow                          // Na\n")
	fmt.Fprintf(w, "\tEAW_Neutral                         // N\n")
	fmt.Fprintf(w, "\tEAW_Ambiguous                       // A\n\n")
	fmt.Fprintf(w, "\t// General categories\n")
	fmt.Fprintf(w, "\tIsCombiningMark                     // Mn, Mc, Me\n")
	fmt.Fprintf(w, "\tIsControlChar                       // C0, C1, DEL\n")
	fmt.Fprintf(w, "\tIsZeroWidth                         // ZWSP, ZWJ, ZWNJ, etc.\n")
	fmt.Fprintf(w, "\tIsEmoji                             // Emoji base characters\n")
	fmt.Fprintf(w, "\tIsEmojiModifier                     // Emoji modifiers\n")
	fmt.Fprintf(w, "\tIsEmojiVariationSelector            // Emoji variation selectors\n")
	fmt.Fprintf(w, ")\n\n")

	// Write helper methods
	fmt.Fprintf(w, "// Has returns true if the property flag is set\n")
	fmt.Fprintf(w, "func (p property) Has(flag property) bool {\n")
	fmt.Fprintf(w, "\treturn p&flag != 0\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// IsEastAsianWide returns true if the character is East Asian Wide\n")
	fmt.Fprintf(w, "func (p property) IsEastAsianWide() bool {\n")
	fmt.Fprintf(w, "\treturn p.Has(EAW_Fullwidth) || p.Has(EAW_Wide)\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// IsEastAsianAmbiguous returns true if the character is East Asian Ambiguous\n")
	fmt.Fprintf(w, "func (p property) IsEastAsianAmbiguous() bool {\n")
	fmt.Fprintf(w, "\treturn p.Has(EAW_Ambiguous)\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// IsCombining returns true if the character is a combining mark\n")
	fmt.Fprintf(w, "func (p property) IsCombining() bool {\n")
	fmt.Fprintf(w, "\treturn p.Has(IsCombiningMark)\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// IsControl returns true if the character is a control character\n")
	fmt.Fprintf(w, "func (p property) IsControl() bool {\n")
	fmt.Fprintf(w, "\treturn p.Has(IsControlChar)\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// IsZeroWidth returns true if the character has zero width\n")
	fmt.Fprintf(w, "func (p property) IsZeroWidth() bool {\n")
	fmt.Fprintf(w, "\treturn p.Has(IsZeroWidth)\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// IsEmoji returns true if the character is an emoji\n")
	fmt.Fprintf(w, "func (p property) IsEmoji() bool {\n")
	fmt.Fprintf(w, "\treturn p.Has(IsEmoji)\n")
	fmt.Fprintf(w, "}\n\n")

}

// writeLookupFunction writes the actual lookup functions that use the generated trie
func writeLookupFunction(w *os.File) {
	fmt.Fprintf(w, "// Global trie instance\n")
	fmt.Fprintf(w, "var stringWidthTrie = &stringWidthTrie{}\n\n")

	fmt.Fprintf(w, "// LookupCharPropertiesBytes returns the properties for the first character in a byte slice\n")
	fmt.Fprintf(w, "func LookupCharPropertiesBytes(s []byte) (property, int) {\n")
	fmt.Fprintf(w, "\tif len(s) == 0 {\n")
	fmt.Fprintf(w, "\t\treturn 0, 0\n")
	fmt.Fprintf(w, "\t}\n\n")
	fmt.Fprintf(w, "\t// Use the generated trie for lookup\n")
	fmt.Fprintf(w, "\tprops, size := stringWidthTrie.lookup(s)\n")
	fmt.Fprintf(w, "\treturn props, size\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// LookupCharPropertiesString returns the properties for the first character in a string\n")
	fmt.Fprintf(w, "func LookupCharPropertiesString(s string) (property, int) {\n")
	fmt.Fprintf(w, "\tif len(s) == 0 {\n")
	fmt.Fprintf(w, "\t\treturn 0, 0\n")
	fmt.Fprintf(w, "\t}\n\n")
	fmt.Fprintf(w, "\t// Use the generated trie for lookup\n")
	fmt.Fprintf(w, "\tprops, size := stringWidthTrie.lookup(s)\n")
	fmt.Fprintf(w, "\treturn props, size\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// LookupCharProperties returns the properties for a given rune\n")
	fmt.Fprintf(w, "func LookupCharProperties(r rune) property {\n")
	fmt.Fprintf(w, "\t// Check for invalid runes\n")
	fmt.Fprintf(w, "\tif r == unicode.ReplacementChar || r > unicode.MaxRune {\n")
	fmt.Fprintf(w, "\t\treturn 0\n")
	fmt.Fprintf(w, "\t}\n\n")
	fmt.Fprintf(w, "\t// Convert rune to string and use stringish lookup\n")
	fmt.Fprintf(w, "\tprops, _ := LookupCharPropertiesString(string(r))\n")
	fmt.Fprintf(w, "\treturn props\n")
	fmt.Fprintf(w, "}\n\n")
}
