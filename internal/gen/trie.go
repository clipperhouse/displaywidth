// Package trie handles the generation of compressed tries for character properties
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"unicode"

	"github.com/clipperhouse/displaywidth/internal/gen/triegen"
)

// GenerateTrie creates a compressed trie from Unicode data using triegen
func GenerateTrie(data *UnicodeData) (*triegen.Trie, error) {
	trie := triegen.NewTrie("stringWidth")

	// Insert all characters with non-default properties
	inserted := 0
	for r := rune(0); r <= 0x10FFFF; r++ {
		// Skip surrogate characters (U+D800-U+DFFF) and other invalid characters
		if r >= 0xD800 && r <= 0xDFFF {
			continue
		}

		// Skip characters that would create invalid UTF-8
		if r == unicode.ReplacementChar {
			continue
		}

		props := BuildPropertyBitmap(r, data)

		// Only insert characters with non-default properties
		if props != 0 {
			trie.Insert(r, uint64(props))
			inserted++
		}
	}

	fmt.Printf("Inserted %d characters with non-default properties\n", inserted)
	return trie, nil
}

// WriteTrieGo generates the Go code for the trie using triegen
func WriteTrieGo(trie *triegen.Trie, outputPath string) error {
	buf := &bytes.Buffer{}

	// Write package header
	fmt.Fprintf(buf, "// Code generated by internal/gen/main.go. DO NOT EDIT.\n\n")
	fmt.Fprintf(buf, "package displaywidth\n\n")
	fmt.Fprintf(buf, "import \"github.com/clipperhouse/displaywidth/internal/stringish\"\n\n")

	// Generate the trie using triegen (it will use uint8/uint16/etc directly)
	size, err := trie.Gen(buf)
	if err != nil {
		return fmt.Errorf("failed to generate trie: %v", err)
	}

	b := buf.Bytes()
	typename := "stringWidthTrie"

	// Add property type alias and constants before the trie definition
	propertyDef := writeCharPropertiesString()
	// Insert after imports, before the trie code
	importEnd := []byte("import \"github.com/clipperhouse/displaywidth/internal/stringish\"\n\n")
	b = bytes.Replace(b, importEnd, append(importEnd, []byte(propertyDef)...), 1)

	typeDefSig := `type ` + typename + ` struct`
	noTypeDef := `// ` + typeDefSig
	b = bytes.ReplaceAll(b, []byte(typeDefSig), []byte(noTypeDef))

	lookupSig := `(t *` + typename + `) lookup(s []byte)`
	genericLookupSig := `lookup[T stringish.Interface](s T)`
	b = bytes.ReplaceAll(b, []byte(lookupSig), []byte(genericLookupSig))

	lookupValueSig := `(t *` + typename + `) lookupValue`
	genericLookupValueSig := `lookupValue`
	b = bytes.ReplaceAll(b, []byte(lookupValueSig), []byte(genericLookupValueSig))

	lookupCallSig := `t.lookupValue(`
	genericLookupCallSig := `lookupValue(`
	b = bytes.ReplaceAll(b, []byte(lookupCallSig), []byte(genericLookupCallSig))

	// Replace uint8 return type in lookup with property and add necessary casts
	b = bytes.ReplaceAll(b, []byte(") (v uint8, sz int)"), []byte(") (v property, sz int)"))
	b = bytes.ReplaceAll(b, []byte(") uint8 {"), []byte(") property {"))
	b = bytes.ReplaceAll(b, []byte("func lookupValue(n uint32, b byte) uint8"), []byte("func lookupValue(n uint32, b byte) property"))
	// Cast return values from Values array (uint8) to property
	b = bytes.ReplaceAll(b, []byte("return stringWidthValues["), []byte("return property(stringWidthValues["))
	b = bytes.ReplaceAll(b, []byte("], 1"), []byte("]), 1"))
	b = bytes.ReplaceAll(b, []byte("return uint8(stringWidthValues["), []byte("return property(stringWidthValues["))

	formatted, err := format.Source(b)
	if err != nil {
		return err
	}

	dst, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer dst.Close()

	_, err = dst.Write(formatted)
	if err != nil {
		return err
	}

	fmt.Printf("Generated trie with size %d bytes\n", size)
	return nil
}

// writeCharPropertiesString returns the character properties definitions as a string
func writeCharPropertiesString() string {
	var buf bytes.Buffer

	fmt.Fprintf(&buf, "// property represents the properties of a character as bit flags\n")
	fmt.Fprintf(&buf, "// The underlying type is uint8 since we only use 7 bits for flags.\n")
	fmt.Fprintf(&buf, "type property uint8\n\n")
	fmt.Fprintf(&buf, "const (\n")
	fmt.Fprintf(&buf, "\t// East Asian Width properties\n")
	fmt.Fprintf(&buf, "\t_EAW_Fullwidth property = 1 << iota // F\n")
	fmt.Fprintf(&buf, "\t_EAW_Wide                            // W\n")
	fmt.Fprintf(&buf, "\t_EAW_Ambiguous                       // A\n\n")
	fmt.Fprintf(&buf, "\t// General categories\n")
	fmt.Fprintf(&buf, "\t_CombiningMark // Mn, Me (Mc excluded for proper width)\n")
	fmt.Fprintf(&buf, "\t_ControlChar  // C0, C1, DEL\n")
	fmt.Fprintf(&buf, "\t_ZeroWidth    // ZWSP, ZWJ, ZWNJ, etc.\n")
	fmt.Fprintf(&buf, "\t_Emoji        // Emoji base characters\n")
	fmt.Fprintf(&buf, ")\n\n")

	return buf.String()
}
